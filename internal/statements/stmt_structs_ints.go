// Code generated by walklox/internal/tools. DO NOT EDIT.

package statements

import (
	"devZ/lox/internal/expressions"
	"devZ/lox/internal/tokens"
)

type Stmt interface {
	Accept(v Visitor) interface{}
}

type Visitor interface {
	VisitExpression(expst *Expression) interface{}
	VisitPrint(prnst *Print) interface{}
	VisitVarStmt(varst *VarStmt) interface{}
	VisitBlock(blk *Block) interface{}
	VisitIf(ifst *If) interface{}
}

type Expression struct {
	expression expressions.Expr
}

type Print struct {
	expression expressions.Expr
}

type VarStmt struct {
	name        *tokens.Token
	initializer expressions.Expr
}

type Block struct {
	statements []Stmt
}

type If struct {
	condition  expressions.Expr
	thenBranch Stmt
	elseBranch Stmt
}

func (expst *Expression) Accept(v Visitor) interface{} {
	return v.VisitExpression(expst)
}

func (expst *Expression) Expression() expressions.Expr {
	return expst.expression
}

func (expst *Expression) SetExpression(ex expressions.Expr) {
	expst.expression = ex
}

func (prnst *Print) Accept(v Visitor) interface{} {
	return v.VisitPrint(prnst)
}

func (prnst *Print) Expression() expressions.Expr {
	return prnst.expression
}

func (prnst *Print) SetExpression(ex expressions.Expr) {
	prnst.expression = ex
}

func (varst *VarStmt) Accept(v Visitor) interface{} {
	return v.VisitVarStmt(varst)
}

func (varst *VarStmt) Name() *tokens.Token {
	return varst.name
}

func (varst *VarStmt) Initializer() expressions.Expr {
	return varst.initializer
}

func (varst *VarStmt) SetName(nm *tokens.Token) {
	varst.name = nm
}

func (varst *VarStmt) SetInitializer(init expressions.Expr) {
	varst.initializer = init
}

func (blk *Block) Accept(v Visitor) interface{} {
	return v.VisitBlock(blk)
}

func (blk *Block) Statements() []Stmt {
	return blk.statements
}

func (blk *Block) SetStatements(stmts []Stmt) {
	blk.statements = stmts
}

func (ifst *If) Accept(v Visitor) interface{} {
	return v.VisitIf(ifst)
}

func (ifst *If) Condition() expressions.Expr {
	return ifst.condition
}

func (ifst *If) ThenBranch() Stmt {
	return ifst.thenBranch
}

func (ifst *If) ElseBranch() Stmt {
	return ifst.elseBranch
}

func (ifst *If) SetCondition(cnd expressions.Expr) {
	ifst.condition = cnd
}

func (ifst *If) SetThenBranch(thbr Stmt) {
	ifst.thenBranch = thbr
}

func (ifst *If) SetElseBranch(elbr Stmt) {
	ifst.elseBranch = elbr
}

func NewExpression(ex expressions.Expr) *Expression {
	return &Expression{
		expression: ex,
	}
}

func NewPrint(ex expressions.Expr) *Print {
	return &Print{
		expression: ex,
	}
}

func NewVarStmt(nm *tokens.Token, init expressions.Expr) *VarStmt {
	return &VarStmt{
		name:        nm,
		initializer: init,
	}
}

func NewBlock(stmts []Stmt) *Block {
	return &Block{
		statements: stmts,
	}
}

func NewIf(cnd expressions.Expr, thbr Stmt, elbr Stmt) *If {
	return &If{
		condition:  cnd,
		thenBranch: thbr,
		elseBranch: elbr,
	}
}
